# Object Relational Mapping

When we talk about relational databases and object-oriented models, we're really talking about two different ways or two different models for representing data, specifically entities. Now, relational databases, they model entities using an ordered set of attributes. Now, we typically call those rows and the formal name is tuples, but in general it's safe to think of 'em as just like rows that are organized into collections and we call these collections tables. Now, object-oriented models, on the other hand, are organized around two concepts called class and instance. Now, a class or classes describe the structure of an object, and an instance, or instances, those are actual objects that store data about a particular entity, so these are some key terms you want to keep in mind when you're thinking about object-relational mappings. Now, there are definitely similarities across these models. So, for example, both kinds of models are used to represent entities. In a relational model, an entity is described by a row, which has attributes. In the object-oriented models, an entity is described by an instance and an instance has instance variables, so that's some of the basic concepts that we want to keep in mind as we work through this idea of object relational mapping.

Now we're going to take a look at a particular Object relational mapping platform or ORM. And this one is called SQLAlchemy. SQLAlchemy is a Python SQL toolkit and it's designed to map between objects and relations. Now, basically the way we often think about it is that tables, or more specifically relations, because it could include views for example. Those tables are mapped to classes. And SQLAlchemy is designed to perform many of the low-level tasks associated with mapping from a class to SQL statements. But SQLAlchemy also allows developers to use SQL statements so you can explicitly write a SQL statement and use that as well when you're using SQLAlchemy. The reason we can do this is because SQLAlchemy has two basic components. One is called Core and that does the basic database operations. And then, there is the ORM component and that's the part that does the mapping between object and relational models. Now, SQLAlchemy provides functions that do several kinds of high-level operations like connecting to a database or declaring a mapping which is basically a specification of how you map rows in a table to a particular instances. There are functions for creating sessions as well as, for updating, adding, and deleting data. And of course, you can also query data using SQLAlchemy. And one thing that's important when you're working with transaction processing systems, is the ability to perform commits and rollbacks. And that's also supported with SQLAlchemy. So, some things to keep in mind about SQLAlchemy is that it's built on the industry standard DBAPI. So, it's very easy to work with different databases. And SQLAlchemy allows you to work in an object-oriented fashion and then generates SQL for you. So, it does the mapping, but literal mapping in terms of mapping object statements into SQL statements which can execute and actually return the data or operate on the data as you specify. And one of the nice benefits of this is that it abstracts away database-specific implementation details. So, for example, if you are writing an application, and you want to be able to easily port your application to use either ISQL or a postgreSQL backend, then using SQlAlchemy can actually make that easier because you don't have to worry about implementing maybe a mySQL-specific SQL statement in your application. You'll let SQLAlchemy do the mapping from your object structure to whatever specific SQL statement is required for the backend you're using. So, that's one of the big advantages of using an object relational mapper is that in addition to allowing you to work in your object... In addition to allowing you to work in your object modeling paradigm, which you're maybe doing across your application, it also abstracts away some of the database specifics so you can more easily move your application and use it with different backends.
