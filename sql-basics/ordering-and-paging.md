# Ordering and Paging

I'm sure that by now you've had enough of hearing me say this, but I'm going to say it again anyway. Sets have no order. In the relational model, neither the attributes nor the tuples have any order. Their SQL counterparts, rows and columns, were not so lucky. SQL supports ordering of both rows and of referencing expressions by their ordinal position. First, let's get expression order out of the way. Most databases support referencing select list expressions using their ordinal position as they are listed from left to right. Theoretically the select clause is evaluated after the having clause, and no previous clauses should be aware of these positions. And SQL server does follow this logical order, and allows referencing expressions by position only after they are evaluated, meaning it is only allowed in the order by clause, the only clause that follows the select. Other databases include the MySQL and PostgreSQL allow us to reference expressions by position even in clauses that logically precede the select such as the group by clause. But I really hope that none of you think that order by two comma five comma one has any advantage over specifying the attribute names, species, breed, and name. The only thing we might save are a few keystrokes, and if we are using a reasonable IDE with auto-complete, then you're saving very little.

<figure><img src="../.gitbook/assets/image (73).png" alt=""><figcaption></figcaption></figure>

This query is not valid and attempting to execute it results in an error. Order by items must appear in the select list if select distinct is specified. Can you see why that is? If not, review video two of the grouping chapter once again. The one we discussed, group by verses distinct for eliminating duplicates. Adding distinct effectively groups by all select expressions. And duplicate rows will be grouped into one. The grouping is done only for the select list expression, so any other expression may have multiple values for each group. This is exactly the same logical reason that we couldn't reference any expression which was not part of the group by without an aggregate function. In trying to order rows, which in fact are row groups because of the distinct, doesn't make any sense. Each group of rows may have more than one adoption date for each animal if the animal was adopted, returned, and adopted again.&#x20;

As long as our sorting expressions are unique, there is no ambiguity regarding the ordinal position of each row. If these sorting expressions are not unique, we have to deal with sorting of tied row. When two or more rows share the same sorting value, the database may return those in any order that it sees fit, and it would still count as a valid correct result. To save yourself grief, always treat presentation order of tied rows as if it was completely random and indeterministic.
