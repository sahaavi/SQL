# Ordering and Paging

I'm sure that by now you've had enough of hearing me say this, but I'm going to say it again anyway. Sets have no order. In the relational model, neither the attributes nor the tuples have any order. Their SQL counterparts, rows and columns, were not so lucky. SQL supports ordering of both rows and of referencing expressions by their ordinal position. First, let's get expression order out of the way. Most databases support referencing select list expressions using their ordinal position as they are listed from left to right. Theoretically the select clause is evaluated after the having clause, and no previous clauses should be aware of these positions. And SQL server does follow this logical order, and allows referencing expressions by position only after they are evaluated, meaning it is only allowed in the order by clause, the only clause that follows the select. Other databases include the MySQL and PostgreSQL allow us to reference expressions by position even in clauses that logically precede the select such as the group by clause. But I really hope that none of you think that order by two comma five comma one has any advantage over specifying the attribute names, species, breed, and name. The only thing we might save are a few keystrokes, and if we are using a reasonable IDE with auto-complete, then you're saving very little.

<figure><img src="../.gitbook/assets/image (73).png" alt=""><figcaption></figcaption></figure>

This query is not valid and attempting to execute it results in an error. Order by items must appear in the select list if select distinct is specified. Can you see why that is? If not, review video two of the grouping chapter once again. The one we discussed, group by verses distinct for eliminating duplicates. Adding distinct effectively groups by all select expressions. And duplicate rows will be grouped into one. The grouping is done only for the select list expression, so any other expression may have multiple values for each group. This is exactly the same logical reason that we couldn't reference any expression which was not part of the group by without an aggregate function. In trying to order rows, which in fact are row groups because of the distinct, doesn't make any sense. Each group of rows may have more than one adoption date for each animal if the animal was adopted, returned, and adopted again.&#x20;

As long as our sorting expressions are unique, there is no ambiguity regarding the ordinal position of each row. If these sorting expressions are not unique, we have to deal with sorting of tied row. When two or more rows share the same sorting value, the database may return those in any order that it sees fit, and it would still count as a valid correct result. To save yourself grief, always treat presentation order of tied rows as if it was completely random and indeterministic.

Null, not being a value, doesn't make sense for sorting. It can't be compared to a value, so we can't tell if it is higher or lower than any other value. Unfortunately the ANSI SQL standard doesn't specify any rules regarding ordering of nulls. So different databases chose to treat them differently. SQL server and MySQL treat nulls as if they had the lowest sorting value, which means that nulls will appear first when sorting with ascending order and last when sorting with descending. PostgreSQL and Oracle treat them the other way around. However, the latter do support explicit null ordering using the nulls first and nulls last keywords. First and last will be respected always regardless if we use descending or ascending sort order.

Paging, or pagination is the process of separating large row sets into smaller, disgestable chunks known as pages. Now, theoretically, this task is also the sole responsibility of the presentation tier and not that of the database. But as Albert Einstein once said, "In theory, theory and practice are the same. "In practice, they are not." Overloading the calling application or the middle tier with huge and potentially unused datasets may not always be the best course of action. So for paging purposes, I will take off my purist hat for a minute and consent that it does make sense to perform this task much closer to the data, and SQL is as close as it gets. Paging doesn't make sense without an order by, and in most databases, they are inseparable.
